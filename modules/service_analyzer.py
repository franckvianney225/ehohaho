# modules/service_analyzer.py
# Analyse et interpr√©tation des r√©sultats de scan

from core.colors import green, yellow, red, cyan, blue, magenta
from core.logger import PentestLogger

log = PentestLogger()

# Base de donn√©es des services et risques
SERVICE_DB = {
    # Services UDP critiques
    "dns": {
        "port": 53,
        "protocol": "udp",
        "risk_level": "medium",
        "description": "Service DNS - R√©solution de noms de domaine",
        "risks": [
            "√ânum√©ration de zones DNS (zone transfer)",
            "Cache poisoning possible",
            "R√©v√©lation d'informations internes",
            "Amplification DDoS possible"
        ],
        "recommendations": [
            "V√©rifier la configuration des zone transfers",
            "Impl√©menter DNSSEC si possible",
            "Limiter les requ√™tes r√©cursives",
            "Surveiller les requ√™tes anormales"
        ],
        "tests": [
            "nslookup -type=any {target}",
            "dig axfr @{target} domain.com",
            "dnsrecon -t axfr -d domain.com -n {target}"
        ]
    },
    
    "snmp": {
        "port": 161,
        "protocol": "udp",
        "risk_level": "high",
        "description": "SNMP - Protocole de gestion r√©seau",
        "risks": [
            "Community strings faibles (public/private)",
            "R√©v√©lation d'informations syst√®me sensibles",
            "Possibilit√© de modification de configuration",
            "√ânum√©ration compl√®te du r√©seau"
        ],
        "recommendations": [
            "Changer les community strings par d√©faut",
            "Utiliser SNMPv3 avec authentification",
            "Filtrer l'acc√®s SNMP par IP",
            "D√©sactiver SNMP si non n√©cessaire"
        ],
        "tests": [
            "snmpwalk -v2c -c public {target}",
            "snmpwalk -v2c -c private {target}",
            "onesixtyone -c community.txt {target}"
        ]
    },
    
    "ntp": {
        "port": 123,
        "protocol": "udp",
        "risk_level": "low",
        "description": "NTP - Synchronisation d'horloge r√©seau",
        "risks": [
            "Amplification DDoS (r√©flexion)",
            "R√©v√©lation d'informations syst√®me",
            "Manipulation possible de l'heure syst√®me"
        ],
        "recommendations": [
            "Configurer des restrictions d'acc√®s",
            "Utiliser NTP authentifi√© si possible",
            "Monitorer les requ√™tes anormales",
            "Limiter les commandes de monitoring"
        ],
        "tests": [
            "ntpq -p {target}",
            "ntpdate -q {target}",
            "nmap -sU -p123 --script ntp-monlist {target}"
        ]
    },
    
    # Services TCP critiques
    "ssh": {
        "port": 22,
        "protocol": "tcp",
        "risk_level": "medium",
        "description": "SSH - Acc√®s √† distance s√©curis√©",
        "risks": [
            "Brute force sur mots de passe faibles",
            "Vuln√©rabilit√©s dans les versions anciennes",
            "Cl√©s SSH mal configur√©es",
            "Acc√®s privil√©gi√© si compromis"
        ],
        "recommendations": [
            "Utiliser l'authentification par cl√©s",
            "D√©sactiver l'acc√®s root direct",
            "Changer le port par d√©faut",
            "Impl√©menter fail2ban"
        ],
        "tests": [
            "ssh {target} -o PreferredAuthentications=none",
            "hydra -l admin -P passwords.txt ssh://{target}",
            "nmap --script ssh-auth-methods {target}"
        ]
    },
    
    "http": {
        "port": 80,
        "protocol": "tcp", 
        "risk_level": "medium",
        "description": "HTTP - Serveur web non chiffr√©",
        "risks": [
            "Trafic non chiffr√© (interception)",
            "Vuln√©rabilit√©s web (XSS, SQLi, etc.)",
            "R√©v√©lation d'informations sensibles",
            "Attaques sur applications web"
        ],
        "recommendations": [
            "Migrer vers HTTPS",
            "Impl√©menter des headers de s√©curit√©",
            "Scanner les vuln√©rabilit√©s web",
            "Auditer les applications h√©berg√©es"
        ],
        "tests": [
            "curl -I http://{target}",
            "nikto -h {target}",
            "gobuster dir -u http://{target} -w wordlist.txt"
        ]
    }
}

def get_risk_color(risk_level: str) -> callable:
    """Retourne la couleur selon le niveau de risque"""
    colors = {
        "critical": red,
        "high": red,
        "medium": yellow,
        "low": green,
        "info": cyan
    }
    return colors.get(risk_level, cyan)

def analyze_service(service_name: str, port: int, protocol: str, banner: str = None) -> dict:
    """Analyse un service d√©tect√©"""
    service_info = SERVICE_DB.get(service_name, {
        "risk_level": "info",
        "description": f"Service inconnu sur port {port}/{protocol}",
        "risks": ["Service non identifi√© - analyse manuelle requise"],
        "recommendations": ["Identifier le service manuellement", "V√©rifier les vuln√©rabilit√©s connues"],
        "tests": [f"nmap -sV -p {port} {{target}}"]
    })
    
    # Ajouter des infos contextuelles
    service_info["detected_port"] = port
    service_info["detected_protocol"] = protocol
    service_info["banner"] = banner
    
    return service_info


def normalize_service_name(service_name: str, port: int, protocol: str) -> str:
    """Normalise les noms de services pour la base de donn√©es"""
    # Mapping des services alternatifs
    service_mapping = {
        "domain": "dns",  # ‚Üê Fix pour votre probl√®me
        "nameserver": "dns",
        "http-alt": "http",
        "http-proxy": "http", 
        "https-alt": "https",
        "ssh-alt": "ssh",
        "telnet-alt": "telnet"
    }
    
    # V√©rification par port si le service n'est pas reconnu
    port_mapping = {
        53: "dns",
        80: "http", 
        443: "https",
        22: "ssh",
        161: "snmp",
        123: "ntp",
        21: "ftp",
        25: "smtp",
        110: "pop3",
        143: "imap",
        993: "imaps",
        995: "pop3s"
    }
    
    # Essayer le mapping par nom d'abord
    normalized = service_mapping.get(service_name.lower(), service_name.lower())
    
    # Si toujours pas trouv√©, essayer par port
    if normalized == service_name.lower() and normalized not in SERVICE_DB:
        normalized = port_mapping.get(port, service_name.lower())
    
    return normalized

# Modifiez la fonction analyze_service
def analyze_service(service_name: str, port: int, protocol: str, banner: str = None) -> dict:
    """Analyse un service d√©tect√©"""
    # Normaliser le nom du service
    normalized_service = normalize_service_name(service_name, port, protocol)
    
    service_info = SERVICE_DB.get(normalized_service, {
        "risk_level": "info",
        "description": f"Service {service_name} sur port {port}/{protocol}",
        "risks": ["Service n√©cessite une analyse manuelle approfondie"],
        "recommendations": [
            "Identifier pr√©cis√©ment le service et sa version", 
            "Rechercher les vuln√©rabilit√©s CVE associ√©es",
            "V√©rifier la configuration de s√©curit√©"
        ],
        "tests": [f"nmap -sV -sC -p {port} {{target}}"]
    })
    
    # Ajouter des infos contextuelles
    service_info["detected_port"] = port
    service_info["detected_protocol"] = protocol
    service_info["detected_service_name"] = service_name  # Service original
    service_info["normalized_service_name"] = normalized_service  # Service normalis√©
    service_info["banner"] = banner
    
    return service_info


def interpret_scan_results(scan_results: list[dict]) -> dict:
    """Interpr√®te les r√©sultats d'un scan complet"""
    interpretation = {
        "summary": {
            "total_ports": len(scan_results),
            "open_ports": 0,
            "services_identified": 0,
            "risk_distribution": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        },
        "services": [],
        "recommendations": set(),
        "immediate_actions": [],
        "further_testing": []
    }
    
    for result in scan_results:
        if result["state"].startswith("open"):
            interpretation["summary"]["open_ports"] += 1
            
            # Analyser le service
            service_analysis = analyze_service(
                result["service"], 
                result["port"], 
                result["proto"],
                result.get("banner")
            )
            
            interpretation["services"].append({
                "port": result["port"],
                "protocol": result["proto"],
                "service": result["service"],
                "analysis": service_analysis
            })
            
            # Compter les risques
            risk_level = service_analysis.get("risk_level", "info")
            interpretation["summary"]["risk_distribution"][risk_level] += 1
            
            # Ajouter recommandations
            for rec in service_analysis.get("recommendations", []):
                interpretation["recommendations"].add(rec)
            
            # Actions imm√©diates pour services critiques/high
            if risk_level in ["critical", "high"]:
                interpretation["immediate_actions"].append(f"Port {result['port']}/{result['proto']} ({result['service']}) - Risque {risk_level}")
            
            # Tests suppl√©mentaires
            interpretation["further_testing"].extend(service_analysis.get("tests", []))
    
    interpretation["recommendations"] = list(interpretation["recommendations"])
    return interpretation

def print_detailed_analysis(interpretation: dict, target: str):
    """Affiche une analyse d√©taill√©e"""
    print(f"\n{cyan('='*60)}")
    print(f"{cyan('ANALYSE DES R√âSULTATS DE SCAN')}")
    print(f"{cyan('='*60)}")
    
    summary = interpretation["summary"]
    print(f"\n{blue('üìä R√âSUM√â')}")
    print(f"‚Ä¢ Cible analys√©e: {target}")
    print(f"‚Ä¢ Ports ouverts: {summary['open_ports']}/{summary['total_ports']}")
    print(f"‚Ä¢ Services identifi√©s: {len(interpretation['services'])}")
    
    # Distribution des risques
    print(f"\n{blue('‚ö†Ô∏è  R√âPARTITION DES RISQUES')}")
    risk_dist = summary["risk_distribution"]
    for risk, count in risk_dist.items():
        if count > 0:
            color = get_risk_color(risk)
            print(f"‚Ä¢ {color(risk.upper())}: {count} service(s)")
    
    # Actions imm√©diates
    if interpretation["immediate_actions"]:
        print(f"\n{red('üö® ACTIONS IMM√âDIATES RECOMMAND√âES')}")
        for action in interpretation["immediate_actions"]:
            print(f"‚Ä¢ {red(action)}")
    
    # Analyse d√©taill√©e par service
    print(f"\n{blue('üîç ANALYSE D√âTAILL√âE PAR SERVICE')}")
    for service in interpretation["services"]:
        analysis = service["analysis"]
        color = get_risk_color(analysis["risk_level"])
        
        print(f"\n{color(f'üì° {service["service"].upper()}')} - Port {service['port']}/{service['protocol']}")
        print(f"   Description: {analysis['description']}")
        print(f"   Niveau de risque: {color(analysis['risk_level'].upper())}")
        
        if "risks" in analysis:
            print(f"   {yellow('Risques identifi√©s:')}")
            for risk in analysis["risks"]:
                print(f"   ‚Ä¢ {risk}")
    
    # Recommandations g√©n√©rales
    if interpretation["recommendations"]:
        print(f"\n{blue('üí° RECOMMANDATIONS DE S√âCURIT√â')}")
        for i, rec in enumerate(interpretation["recommendations"], 1):
            print(f"{i}. {rec}")
    
    # Tests suppl√©mentaires
    if interpretation["further_testing"]:
        print(f"\n{blue('üß™ TESTS SUPPL√âMENTAIRES SUGG√âR√âS')}")
        unique_tests = list(set(interpretation["further_testing"]))
        for i, test in enumerate(unique_tests[:10], 1):  # Limite √† 10 tests
            formatted_test = test.replace("{target}", target)
            print(f"{i}. {formatted_test}")
    
    print(f"\n{cyan('='*60)}")

def generate_executive_summary(interpretation: dict, target: str) -> str:
    """G√©n√®re un r√©sum√© ex√©cutif"""
    summary = interpretation["summary"]
    risk_dist = summary["risk_distribution"]
    
    total_risk_services = risk_dist["critical"] + risk_dist["high"] + risk_dist["medium"]
    
    if risk_dist["critical"] > 0:
        risk_level = "CRITIQUE"
        color = "üî¥"
    elif risk_dist["high"] > 0:
        risk_level = "√âLEV√â"
        color = "üü†"
    elif risk_dist["medium"] > 0:
        risk_level = "MOD√âR√â"
        color = "üü°"
    else:
        risk_level = "FAIBLE"
        color = "üü¢"
    
    return f"""
{color} R√âSUM√â EX√âCUTIF - SCAN DE {target}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Niveau de risque global: {risk_level}
Services expos√©s: {summary['open_ports']} port(s) ouvert(s)
Services √† risque: {total_risk_services} service(s) n√©cessitent une attention

Actions prioritaires: {len(interpretation['immediate_actions'])} action(s) imm√©diate(s)
Tests recommand√©s: {len(set(interpretation['further_testing']))} test(s) suppl√©mentaire(s)
"""